<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verkefni 4 - Buddha</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <h1>Buddha Model</h1>

    <div class="buddha-info">
        <h2>Um Buddha</h2>
        <p>
          Buddha var andlegur leiðtogi sem kenndi leiðina að uppljómun 
          og innri friði. Hugmyndir hans leggja áherslu á visku, siðferði 
          og hugleiðslu sem verkfæri til að ná frelsi frá þjáningu.
          Þessi gaur tjillar inni hjá mér, á skrifborði mínu.
        </p>
    </div>
    
    <div class="container">
        <div class="text">
            <a href="static/3dBuddha.glb">Download Buddha</a>
        </div>

        <div class="model" id="model">
            <canvas id="c"></canvas>
        </div>
    </div>

    <div class="container">
        <div class="mynd">
            <img src="static/Buddha.jpg" alt="Buddha">
        </div>
    </div>

    <!-- Loading overlay -->
    <div id="loading" class="loading hidden">
        <div id="loading-text">Hleð… 0%</div>
    </div>


    <!-- Importmap fyrir Three.js -->
        <script type="importmap">{
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }</script>

    <!-- AnimeJS Global (nota bara anime(...)) -->
    <script src="https://cdn.jsdelivr.net/npm/animejs@4.1.3/lib/anime.iife.min.js"></script> 

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let ar = false;

        // Loading overlay
        const overlay = document.getElementById('loading');
        const label = document.getElementById('loading-text');

        // LoadingManager
        const manager = new THREE.LoadingManager();
        manager.onLoad = () => { overlay.classList.add('hidden'); };
        manager.onProgress = (_url, loaded, total) => {
        if (total) {
            const pct = Math.round((loaded / total) * 100);
            label.textContent = `Hleð… ${pct}%`;
        } else {
            label.textContent = 'Hleð…';
        }
        };
        manager.onError = (url) => {
        label.textContent = 'Tókst ekki að hlaða.';
        console.error('Load error for:', url);
        };



        // ------------------------- AR MODE -------------------------
        function modelAR() {
            const modeldiv = document.getElementById("model");
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xE8E8E8);

            const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.xr.enabled = true;

            modeldiv.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

            function onSelect() {
                if (reticle.visible) {
                    const gltfLoader = new GLTFLoader(manager);
                    const url = 'static/3dBuddha.glb';

                    overlay.classList.remove('hidden');
                    label.textContent = 'Hleð AR-Modeli…';

                    gltfLoader.load(
                    url,
                    function (gltf) {
                        overlay.classList.add('hidden');   // fela þegar búið að hlaða
                        let model = gltf.scene;
                        reticle.matrix.decompose(model.position, model.quaternion, model.scale);
                        scene.add(model);
                    }
                  );
                }
            }

            const controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            const reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            let hitTestSource = null;
            let hitTestSourceRequested = false;

            function animate(timestamp, frame) {
                if (frame) {
                    ar = true;

                    const referenceSpace = renderer.xr.getReferenceSpace();
                    const session = renderer.xr.getSession();

                    if (hitTestSourceRequested === false) {
                        session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                            session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                                hitTestSource = source;
                            });
                        });

                        session.addEventListener('end', function () {
                            hitTestSourceRequested = false;
                            hitTestSource = null;
                        });

                        hitTestSourceRequested = true;
                    }

                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);

                        if (hitTestResults.length) {
                            const hit = hitTestResults[0];
                            reticle.visible = true;
                            reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                        } else {
                            reticle.visible = false;
                        }
                    }
                }
                renderer.render(scene, camera);
            }
        }

        modelAR();

        // ------------------------- CANVAS MODE -------------------------
        function modelCanvas() {
            const canvas = document.querySelector('#c');
            const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
            renderer.shadowMap.enabled = true;

            // SCENE
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xE8E8E8);

            // CAMERA
            const fov = 10;
            const aspect = 2;
            const near = 0.5;
            const far = 30;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 0, 10);

            // CONTROLS
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, -5);

            // LIGHT
            const color = 0xFFFFFF;
            const intensity = 3;
            const light = new THREE.DirectionalLight(color, intensity);
            light.castShadow = true;
            light.position.set(0, 10, -5);
            scene.add(light);

            // PLANE
            const geometry = new THREE.PlaneGeometry(4, 4);
            const loader = new THREE.TextureLoader();
            const texture = loader.load('static/nature.jpg');
            texture.colorSpace = THREE.SRGBColorSpace;

            const material = new THREE.MeshStandardMaterial({ map: texture, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(geometry, material);
            plane.receiveShadow = true;

            const quaternion = new THREE.Quaternion();
            quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);
            plane.applyQuaternion(quaternion);
            plane.position.set(0, -1, -5);

            scene.add(plane);

            
            // GLTF MODEL
            const gltfLoader = new GLTFLoader(manager);
            const url = 'static/3dBuddha.glb';

            // sýna overlay þegar hleðsla byrjar
            overlay.classList.remove('hidden');
            label.textContent = 'Hleð Modeli...';


            gltfLoader.load(
            url,
            function (gltf) {
                const model = gltf.scene;
                // 1) Uppfæra world
                model.updateMatrixWorld(true);
                // 2) Finna miðju og stærð
                const box = new THREE.Box3().setFromObject(model);
                const size = new THREE.Vector3();
                const center = new THREE.Vector3();
                box.getSize(size);
                box.getCenter(center);
                // 3) Færa geómetríska miðju að (0,0,0)
                model.position.sub(center);
                // 4) Skala: láta max vídd ≈ 2 einingar 
                const maxDim = Math.max(size.x, size.y, size.z) || 1;
                const scale = 2 / maxDim;
                model.scale.setScalar(scale);
                // 5) Setja model yfir plane 
                model.position.set(0, -4.3, -5.5);
                // 6) Bæta strax í senuna
                scene.add(model);
                // 7) Anime aðeins ef til
                if (typeof window.anime === 'function') {
                window.anime({
                    targets: [model.rotation],
                    y: 6.2,
                    easing: 'linear',
                    duration: 5000,
                    loop: true
                });
                }
                // 8) Skuggar
                model.traverse((o) => {
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;
                    if (o.material && o.material.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
                }
                });
            },
            undefined,
            (err) => console.error('GLB load error:', err)
            );

            // RENDER
            function render(time) {
                time *= 0.001;
                controls.update();

                if (resizeRendererToDisplaySize(renderer)) {
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }

                renderer.render(scene, camera);
            }

            renderer.setAnimationLoop(render);

            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;

                if (needResize) {
                    renderer.setSize(width, height, false);
                }
                return needResize;
            }
        }

        if (ar == true) {
            console.log("True");
        } else {
            console.log("false");
            modelCanvas();
        }

    </script>
</body>
</html>
