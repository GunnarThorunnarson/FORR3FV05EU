<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="Static/static.css">
</head>
<body>

    <h1>Ballet Model</h1>
    <div class="container">
        <div class="texti">
            <a href="Static/ballet_static.glb">download model</a>
        </div>

        <div class="model" id="model">
            <canvas id="c"></canvas>
        </div>
    </div>

    <div class="container">
        <div class="myndir">
            <img src="Static/IMG_1824.jpg" alt="ballet girl">
        </div>
    </div>

    <script  type="importmap">{
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three/examples/jsm/"
        }
    }</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';


        let ar = false;

        function modelAR() {

            const modeldiv = document.getElementById("model");
            
            const scene = new THREE.Scene();

            const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );

            const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 3 );
            light.position.set( 0.5, 1, 0.25 );
            scene.add( light );

            const renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setAnimationLoop( animate );
            renderer.xr.enabled = true;


            modeldiv.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );

            const geometry = new THREE.CylinderGeometry( 0.1, 0.1, 0.2, 32 ).translate( 0, 0.1, 0 );
            

            function onSelect() {

                if ( reticle.visible ) {

                    const gtlfLoader = new GLTFLoader();
                
                    // ballet girl
                    const url = './Static/ballet_static.glb';
                    gtlfLoader.load(url, function (gltf) {
                        let model = gltf.scene;
                        reticle.matrix.decompose( model.position, model.quaternion, model.scale );
                        scene.add(model);
                    })

                }
            }

            const controller = renderer.xr.getController( 0 );
            controller.addEventListener( 'select', onSelect );
            scene.add( controller );

            const reticle = new THREE.Mesh(
                new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add( reticle );

            //

            let hitTestSource = null;
            let hitTestSourceRequested = false;

            function animate( timestamp, frame ) {

                if ( frame ) {

                    ar = true;
                
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    const session = renderer.xr.getSession();
                    

                    if ( hitTestSourceRequested === false ) {

                        session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {

                            session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {

                                hitTestSource = source;

                            } );

                        } );

                        session.addEventListener( 'end', function () {

                            hitTestSourceRequested = false;
                            hitTestSource = null;

                        } );

                        hitTestSourceRequested = true;

                    }

                    if ( hitTestSource ) {

                        const hitTestResults = frame.getHitTestResults( hitTestSource );

                        if ( hitTestResults.length ) {

                            const hit = hitTestResults[ 0 ];

                            reticle.visible = true;
                            reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );

                        } else {

                            reticle.visible = false;

                        }

                    }

                }

                renderer.render( scene, camera );
            }

        }


        modelAR();

        function modelCanvas() {
            const canvas = document.querySelector('#c');
            const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
            renderer.shadowMap.enabled = true;


            const loader = new THREE.TextureLoader();


            // ----------- scene ---------------------------------------------------------------------------------------------------
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xE8E8E8);


            // --------- camera ---------------------------------------------------------------------------------------------------

            const fov = 10;
            const aspect = 2;
            const near = 0.5;
            const far = 30;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

            // move camera back to see origin
            camera.position.set(0,0,10);

            // ------------- controls ---------------------------------------------------------------------------------------------------
            const controls = new OrbitControls( camera, renderer.domElement );
            controls.target.set(0,0,-5);

            // ------------- light ---------------------------------------------------------------------------------------------------
            const color = 0xFFFFFF;
            const intensity = 3;
            const light = new THREE.DirectionalLight(color, intensity);
            light.castShadow = true;
            light.position.set(0, 10, -5);
            scene.add(light);

            // ------------- plane ---------------------------------------------------------------------------------------------------

            const width = 4;
            const height = 4;
            const geometry = new THREE.PlaneGeometry(width, height);


            const texture = loader.load( './Static/b1a0aa7409ac989b9ad82f0c2a236af6.jpg' );
            texture.colorSpace = THREE.SRGBColorSpace;

            const material = new THREE.MeshStandardMaterial({map: texture, side: THREE.DoubleSide});
            const plane = new THREE.Mesh(geometry, material);
            plane.receiveShadow = true;


            const quaternion = new THREE.Quaternion();
            quaternion.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), Math.PI / 2 );

            plane.applyQuaternion(quaternion)
            plane.position.set(0,-1,-5);

            scene.add(plane);

            // ------------ gltf object ---------------------------------------------------------------------------------------------------

            const gtlfLoader = new GLTFLoader();

            // ballet girl
            const url = './Static/ballet_static.glb';
            gtlfLoader.load(url, function (gltf) {
                let model = gltf.scene;
                model.scale.set(10,10,10);
                model.position.set(0,0,-5);

                anime({
                    targets: [model.rotation],
                    y: 6.2, x: 0, z: 0,
                    easing: 'linear',
                    duration: 5000,
                    loop: true
                });

                model.traverse((obj) => {
                    if (obj.castShadow !== undefined) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                    }
                })

                scene.add(model);
            })


            // right bunny
            gtlfLoader.load('./Static/CONEJO ANIMACION.glb', function (gltf) {
                let model = gltf.scene;
                model.scale.set(0.3,0.3,0.3);
                model.position.set(1.5,-1.2,-8);

                model.traverse((obj) => {
                    if (obj.castShadow !== undefined) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                    }
                })

                scene.add(model);
            })


            // left bunny
            gtlfLoader.load('./Static/CONEJO ANIMACION.glb', function (gltf) {
                let model = gltf.scene;
                model.scale.set(-0.3,0.3,0.3);
                model.position.set(-1.5,-1.2,-8);

                model.traverse((obj) => {
                    if (obj.castShadow !== undefined) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                    }
                })

                scene.add(model);
            })





            // render scene
            renderer.render(scene, camera);


            // ---------- Render ---------------------------------------------------------------------------------------------------
            function render(time) {
                time *= 0.001;

                controls.update();

                if (resizeRendererToDisplaySize(renderer)) {
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }

                
                renderer.render(scene, camera);
                
                
            }

            renderer.setAnimationLoop( render );

            // resize

            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;

                if (needResize) {
                    renderer.setSize(width, height, false);
                }
                return needResize
            }
        }

        if (ar == true) {
            console.log("True");
        }
        else {
            console.log("false");
            modelCanvas();
        }


    </script>
</body>
</html>