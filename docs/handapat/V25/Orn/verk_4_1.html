<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <title>YOU READ THIS YOU NERD LOOK AT THIS DUDE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
        body {
      font-family: roboto;
      background-color: black;
      margin: 2em;
      color: white;
      display: flex;
    }
    video {
      clear: both;
      display: block;
      transform: rotateY(180deg);
      -webkit-transform: rotateY(180deg);
      -moz-transform: rotateY(180deg);
      height: 280px;
    }
    #output_canvas {
      position: absolute; left: 0px; top: 0px;
      transform: rotateY(180deg);
      -webkit-transform: rotateY(180deg);
      -moz-transform: rotateY(180deg);
    }
    #scene-container {
        display: block;
        width: 50%;
    }
</style>
</head>
<body>
    <div class="sides" style="display: flex; justify-content: space-around;">
        <div>
            <button id='webcamButton'>ENABLE WEBCAM</button>
            <div style='position: relative;'>
                <video id='webcam' autoplay></video>
                <canvas id='output_canvas' width='480' height='360'
                    style='position: absolute; left: 0px; top: 0px;'></canvas>
                    <h2>rotate Y + üëç, rotate Y - üëé, rotate X + ‚úåÔ∏è, rotate X - ü§ü, rotate Z + ‚úä, rotate Z - ‚òùÔ∏è, Restarts rotate üëã</h2>
                <h1 id='gesture_output'></h1>
                <h2>X <span id='x_output'></span></h2>
                <h2>Y <span id='y_output'></span></h2>
            </div>
        </div>
        <div>
            <canvas id="Cube"></canvas>
        </div>
    </div>
    

    
    <script type='module'>
        let gestureteller = "";

        import { GestureRecognizer, FilesetResolver, DrawingUtils } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3';
        
        let gestureRecognizer;
        let runningMode = 'IMAGE';
        let enableWebcamButton;
        let webcamRunning = false;
        const videoWidth = '480px';
        const videoHeight = '360px';
        
        const createGestureRecognizer = async () => {
            const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm');
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task',
                    delegate: 'CPU'
                },
                runningMode: runningMode
            });
        };
        createGestureRecognizer();
        
        const video = document.getElementById('webcam');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const gestureOutput = document.getElementById('gesture_output');
        const xOutput = document.getElementById('x_output');
        const yOutput = document.getElementById('y_output');
    
        enableWebcamButton = document.getElementById('webcamButton');
        enableWebcamButton.addEventListener('click', enableCam);
    
        function enableCam(event) {
            if (!gestureRecognizer) {
                alert('Please wait for gestureRecognizer to load');
                return;
            }
            webcamRunning = !webcamRunning;
            
            const constraints = {
                video: true
            };
            navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
                video.srcObject = stream;
                video.addEventListener('loadeddata', predictWebcam);
            });
        }
    
        let lastVideoTime = -1;
        let results = undefined;
    
        async function predictWebcam() {
            if (runningMode === 'IMAGE') {
                runningMode = 'VIDEO';
                await gestureRecognizer.setOptions({ runningMode: 'VIDEO' });
            }
    
            let nowInMs = Date.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                results = gestureRecognizer.recognizeForVideo(video, nowInMs);
            }
    
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            const drawingUtils = new DrawingUtils(canvasCtx);
            canvasElement.style.height = videoHeight;
            video.style.height = videoHeight;
            canvasElement.style.width = videoWidth;
            video.style.width = videoWidth;
            
            if (results.landmarks) {
                for (const landmarks of results.landmarks) {
                    drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {
                        color: '#00FF00',
                        lineWidth: 5
                    });
                    drawingUtils.drawLandmarks(landmarks, {
                        color: '#FF0000',
                        lineWidth: 2
                    });
                }
            }
            canvasCtx.restore();
            if (results.gestures.length > 0) {
                gestureOutput.style.display = 'block';
                gestureOutput.style.width = videoWidth;
                gestureOutput.innerText = results.gestures[0][0].categoryName;
                gestureteller = results.gestures[0][0].categoryName;  
                xOutput.innerText = results.landmarks[0][0].x.toFixed(2);
                yOutput.innerText = results.landmarks[0][0].y.toFixed(2);
            } else {
                gestureOutput.style.display = 'none';
                gestureteller = 'none';
            }
            if (webcamRunning) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("Cube") });
        renderer.setSize(300, 300);
        document.body.appendChild(renderer.domElement);
    
        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshBasicMaterial({ color: 0x800080 });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
    
        camera.position.z = 2;
    
        function cubeRotation() {
            switch (gestureteller) {
                case 'Thumb_Up':
                    cube.rotation.y += 0.02;
                    break;
                case 'Thumb_Down':
                    cube.rotation.y -= 0.02;
                    break;
                case 'Victory':
                    cube.rotation.x += 0.02;
                    break;
                case 'ILoveYou':
                    cube.rotation.x -= 0.02;
                    break;
                case 'Closed_Fist':
                    cube.rotation.z += 0.02;
                    break;
                case 'Pointing_Up':
                    cube.rotation.z -= 0.02;
                    break;
                case 'Open_Palm':
                    cube.rotation.y = 0;
                    cube.rotation.x = 0;
                    cube.rotation.z = 0;
                    break;
            }



        }
    
        function animate() {
            cubeRotation();
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
    
</body>
</html>