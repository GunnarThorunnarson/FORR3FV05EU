<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>document</title>
  <style>
    body {
      font-family: roboto;
      margin: 2em;
      color: #3d3d3d;
      display: flex;
      gap: 2rem;
    }

    video {
      display: block;
      transform: rotateY(180deg);
      height: 280px;
    }

    #output_canvas {
      position: absolute;
      left: 0;
      top: 0;
      transform: rotateY(180deg);
    }

    #scene-container {
      display: block;
      width: 50%;
      position: relative;
      height: 561px;
    }


    .iconcon {
      display: inline-block;
      font-weight: bold;

    }
  </style>
</head>

<body>
  <div>
    <button id="webcamButton">Loading model...</button>
    <div style="position:relative;">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="output_canvas" width="480" height="480"></canvas>
    </div>
    <div style="margin-top:2rem; display:flex; gap:2rem; justify-content:center;">
      <div style="text-align:center;">
        <div style="font-weight:bold; margin-bottom:0.5rem;">Rotate - Hold this gesture to rotate model</div>
        <img src="icon2.jpg" alt="Rotate gesture" style="height:120px; border-radius:8px; box-shadow:0 2px 8px #ccc;">
      </div>
      <div style="text-align:center;">
        <div style="font-weight:bold; margin-bottom:0.5rem;">Drag - Pinch like this and move your hand left/right</div>
        <img src="Icon1.png" alt="Drag gesture" style="height:120px; border-radius:8px; box-shadow:0 2px 8px #ccc;">
      </div>

      <div style="text-align:center;">
        <div style="font-weight:bold; margin-bottom:0.5rem;">Scale - hold this gestuer to scale. Left hand scales up,
          right hand scales down</div>
        <img src="icon3.webp" alt="Scale gesture" style="height:120px; border-radius:8px; box-shadow:0 2px 8px #ccc;">
      </div>
    </div>
  </div>

  <div id="scene-container"></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@v0.158.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@v0.158.0/examples/jsm/"
    }
  }
  </script>



  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { HandLandmarker, FilesetResolver, DrawingUtils } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3';

    const container = document.querySelector("#scene-container");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color("white");
    const fov = 35, near = 0.1, far = 100;
    const camera = new THREE.PerspectiveCamera(fov, container.clientWidth / container.clientHeight, near, far);
    camera.position.set(0, 10, 30);

    const dir = new THREE.DirectionalLight(0xffffff, 1); dir.position.set(10, 10, 10); scene.add(dir);
    scene.add(new THREE.AmbientLight(0x404040));

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, precision: "lowp" });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    let object = null;
    const placeholder = new THREE.Mesh(
      new THREE.BoxGeometry(4, 4, 4),
      new THREE.MeshStandardMaterial({ color: 0xff0000, opacity: 0.0, transparent: true })
    );
    placeholder.position.set(0, 0, 0);
    scene.add(placeholder);
    object = placeholder;


    let modelBaseScale = 1;
    let modelUserScale = 2.5;
    const user_scale_min = 0.4;
    const user_scale_max = 3.0;

    const loadingManager = new THREE.LoadingManager();
    const loaderObject = new GLTFLoader(loadingManager).setPath('public/models/object/');


    loaderObject.load(
      '3DModel.gltf',
      (gltf) => {
        scene.remove(placeholder);
        object = gltf.scene;

        const bbox = new THREE.Box3().setFromObject(object);
        const size = new THREE.Vector3();
        bbox.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z);
        const desiredSize = 4;
        if (maxDim > 0) {
          const scaleFactor = desiredSize / maxDim;
          object.scale.setScalar(scaleFactor);
        }

        bbox.setFromObject(object);
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        object.position.sub(center);

        bbox.setFromObject(object);
        const minY = bbox.min.y;
        object.position.y -= minY;

        modelBaseScale = object.scale.x || 1;
        modelUserScale = 2.5;
        const applied = THREE.MathUtils.clamp(modelBaseScale * modelUserScale, modelBaseScale * user_scale_min, modelBaseScale * user_scale_max);
        object.scale.setScalar(applied);

        scene.add(object);
        camera.lookAt(object.position);

        enableWebcamButton.textContent = "ENABLE WEBCAM";
        enableWebcamButton.disabled = false;
      },
      undefined,
      (err) => {
        console.error("Failed to load model", err);
        enableWebcamButton.textContent = "ENABLE WEBCAM";

        enableWebcamButton.disabled = false;
      }
    );

    let yangle = 0, xangle = 0;
    let targetCubeX = 0;
    const scene_x_min = -12, scene_x_max = 12;
    const smoothing = 0.15;
    const scale_speed = 0.03;

    function animate() {
      if (object) {
        object.rotation.x = (xangle * Math.PI) / 180;
        object.rotation.y = (yangle * Math.PI) / 180;
        object.position.x += (targetCubeX - object.position.x) * smoothing;

        const wanted = THREE.MathUtils.clamp(modelBaseScale * modelUserScale, modelBaseScale * user_scale_min, modelBaseScale * user_scale_max);
        object.scale.setScalar(wanted);


      }
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener("resize", () => location.reload());

    let handLandmarker = null;
    let runningMode = 'IMAGE';
    let webcamRunning = false;
    const video = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const enableWebcamButton = document.getElementById('webcamButton');
    let lastVideoTime = -1;
    let results = null;

    let pinchLeftCounter = 0, pinchRightCounter = 0;
    let pinchLeftActive = false, pinchRightActive = false;
    let leftCounter = 0, rightCounter = 0;
    let leftActive = false, rightActive = false;
    let leftLCounter = 0, rightLCounter = 0;
    let leftLActive = 0, rightLActive = 0;


    const ACTIVATE_FRAMES = 3;
    const DEACTIVATE_FRAMES = 4;
    const PINCH_ACT_FRAMES = 3, PINCH_DEACT_FRAMES = 3;
    const L_ACTIVATE_FRAMES = 4, L_DEACTIVATE_FRAMES = 4;
    const ROT_SPEED_Y = 1.8, ROT_SPEED_X = 1.0;

    const createHandLandmarker = async () => {
      try {
        const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm');
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task',
            delegate: 'GPU'
          },
          numHands: 2,
          runningMode: runningMode,
        });
        if (!enableWebcamButton.disabled) return;
        enableWebcamButton.disabled = false;
        enableWebcamButton.textContent = "ENABLE WEBCAM";

      } catch (err) {
        enableWebcamButton.disabled = true;
        enableWebcamButton.textContent = "MODEL LOAD FAILED";
      }
    };
    createHandLandmarker();
    enableWebcamButton.disabled = true;


    function dist2D(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); }
    function dist3D(a, b) { const dx = a.x - b.x, dy = a.y - b.y, dz = (a.z || 0) - (b.z || 0); return Math.sqrt(dx * dx + dy * dy + dz * dz); }
    function fingerCurl(landmarks, tipIdx, pipIdx, mcpIdx) {
      const tip_mcp = dist3D(landmarks[tipIdx], landmarks[mcpIdx]);
      const pip_mcp = dist3D(landmarks[pipIdx], landmarks[mcpIdx]);
      if (pip_mcp === 0) return 0;
      return tip_mcp / pip_mcp;
    }
    function vec(a, b) { return { x: b.x - a.x, y: b.y - a.y, z: (b.z || 0) - (a.z || 0) }; }
    function vec2dDot(u, v) { return u.x * v.x + u.y * v.y; }
    function vec2dLen(u) { return Math.sqrt(u.x * u.x + u.y * u.y); }


    function palmX(landmarks) { if (!landmarks) return 0.5; return (landmarks[0].x + landmarks[9].x) / 2; }
    function mapHandXToSceneX(normX) { const t = 1 - normX; return scene_x_min + t * (scene_x_max - scene_x_min); }



    const tip_dist_thresh = 0.06;
    const up_margin = 0.03;
    const Curl_min = 0.6;

    function isIndexMiddleTogetherTolerant(landmarks) {
      if (!landmarks || landmarks.length < 21) return false;
      const IDX = { INDEX_TIP: 8, INDEX_PIP: 6, INDEX_MCP: 5, MIDDLE_TIP: 12, MIDDLE_PIP: 10, MIDDLE_MCP: 9, RING_TIP: 16, RING_PIP: 14, PINKY_TIP: 20, PINKY_PIP: 18, WRIST: 0 };
      const tipDist = dist2D(landmarks[IDX.INDEX_TIP], landmarks[IDX.MIDDLE_TIP]);
      const tipsClose = tipDist < tip_dist_thresh;
      const wristY = landmarks[IDX.WRIST].y;
      const indexUp = landmarks[IDX.INDEX_TIP].y < (landmarks[IDX.INDEX_PIP].y + up_margin) && landmarks[IDX.INDEX_PIP].y < (wristY + up_margin);
      const middleUp = landmarks[IDX.MIDDLE_TIP].y < (landmarks[IDX.MIDDLE_PIP].y + up_margin) && landmarks[IDX.MIDDLE_PIP].y < (wristY + up_margin);
      const indexCurl = fingerCurl(landmarks, IDX.INDEX_TIP, IDX.INDEX_PIP, IDX.INDEX_MCP);
      const middleCurl = fingerCurl(landmarks, IDX.MIDDLE_TIP, IDX.MIDDLE_PIP, IDX.MIDDLE_MCP);
      const indexStraightEnough = indexCurl > Curl_min;
      const middleStraightEnough = middleCurl > Curl_min;
      const ringFolded = landmarks[IDX.RING_TIP].y > (landmarks[IDX.RING_PIP].y - up_margin);
      const pinkyFolded = landmarks[IDX.PINKY_TIP].y > (landmarks[IDX.PINKY_PIP].y - up_margin);
      return tipsClose && indexUp && middleUp && indexStraightEnough && middleStraightEnough && ringFolded && pinkyFolded;


    }

    const pinch_threshold = 0.04;
    const L_straightness_min = 0.6;
    const L_angle_min = 60 * (Math.PI / 180);
    const L_angle_max = 120 * (Math.PI / 180);
    const L_up_margin = 0.03;

    function detectLGesture(landmarks) {

      if (!landmarks || landmarks.length < 21) return 0;
      const IDX = { INDEX_TIP: 8, INDEX_PIP: 6, INDEX_MCP: 5, THUMB_TIP: 4, THUMB_IP: 3, RING_TIP: 16, RING_PIP: 14, PINKY_TIP: 20, PINKY_PIP: 18, MIDDLE_TIP: 12, MIDDLE_PIP: 10, WRIST: 0 };
      const ringFolded = landmarks[IDX.RING_TIP].y > (landmarks[IDX.RING_PIP].y - L_up_margin);
      const pinkyFolded = landmarks[IDX.PINKY_TIP].y > (landmarks[IDX.PINKY_PIP].y - L_up_margin);
      const middleFolded = landmarks[IDX.MIDDLE_TIP].y > (landmarks[IDX.MIDDLE_PIP].y - L_up_margin);
      if (!(ringFolded && pinkyFolded && middleFolded)) return 0;
      const indexCurl = fingerCurl(landmarks, IDX.INDEX_TIP, IDX.INDEX_PIP, IDX.INDEX_MCP);
      if (indexCurl < L_straightness_min) return 0;
      const vIndex = vec(landmarks[IDX.INDEX_MCP], landmarks[IDX.INDEX_TIP]);
      const vIndexLen = vec2dLen(vIndex);
      if (vIndexLen < 0.02) return 0;
      const vThumb = vec(landmarks[IDX.THUMB_IP], landmarks[IDX.THUMB_TIP]);
      const vThumbLen = vec2dLen(vThumb);
      if (vThumbLen < 0.02) return 0;
      const dot = vec2dDot(vIndex, vThumb);
      const cosA = dot / (vIndexLen * vThumbLen);
      const angle = Math.acos(Math.max(-1, Math.min(1, cosA)));
      if (!(angle >= L_angle_min && angle <= L_angle_max)) return 0;
      const indexUp = landmarks[IDX.INDEX_TIP].y < landmarks[IDX.INDEX_MCP].y;
      return indexUp ? 1 : -1;
    }


    function thumbPointsLeft(landmarks) { return (landmarks[4].x - landmarks[3].x) < -0.02; }
    function thumbPointsRight(landmarks) { return (landmarks[4].x - landmarks[3].x) > 0.02; }

    enableWebcamButton.addEventListener('click', async () => {
      if (!handLandmarker) return;
      if (webcamRunning) {
        webcamRunning = false;
        enableWebcamButton.textContent = "ENABLE WEBCAM";

        const tracks = video.srcObject && video.srcObject.getTracks();
        if (tracks) tracks.forEach(t => t.stop());
        return;
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        await video.play();
        webcamRunning = true;
        enableWebcamButton.textContent = "STOP WEBCAM";
        lastVideoTime = -1;
        if (runningMode === "IMAGE") { runningMode = "VIDEO"; await handLandmarker.setOptions({ runningMode: "VIDEO" }); }
        predictWebcam();
      } catch (err) {
        enableWebcamButton.textContent = "CAMERA ERROR";
      }
    });


    async function predictWebcam() {
      if (!handLandmarker) return;
      if (runningMode === "IMAGE") { runningMode = "VIDEO"; await handLandmarker.setOptions({ runningMode: "VIDEO" }); }
      const startTimeMs = performance.now();
      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        results = handLandmarker.detectForVideo(video, startTimeMs);
      }

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      const drawingUtils = new DrawingUtils(canvasCtx);
      canvasElement.style.height = '480px'; video.style.height = '480px';
      canvasElement.style.width = '480px'; video.style.width = '480px';

      let anyRotateGesture = false;
      let anyPinch = false;
      let scaleAction = 0;



      if (results && results.landmarks && results.landmarks.length > 0) {
        let leftIdx = null, rightIdx = null, idx = 0;
        for (const h of results.handednesses) {
          if (h[0].displayName === "Right") rightIdx = idx; else leftIdx = idx;
          idx++;
        }

        if (leftIdx !== null) {
          const g = isIndexMiddleTogetherTolerant(results.landmarks[leftIdx]);
          if (g) leftCounter = Math.min(leftCounter + 1, ACTIVATE_FRAMES);
          else leftCounter = Math.max(leftCounter - 1, -DEACTIVATE_FRAMES);
          leftActive = leftCounter >= ACTIVATE_FRAMES;
        } else { leftCounter = Math.max(leftCounter - 1, -DEACTIVATE_FRAMES); leftActive = leftCounter >= ACTIVATE_FRAMES; }



        if (rightIdx !== null) {
          const g = isIndexMiddleTogetherTolerant(results.landmarks[rightIdx]);
          if (g) rightCounter = Math.min(rightCounter + 1, ACTIVATE_FRAMES);
          else rightCounter = Math.max(rightCounter - 1, -DEACTIVATE_FRAMES);
          rightActive = rightCounter >= ACTIVATE_FRAMES;
        } else { rightCounter = Math.max(rightCounter - 1, -DEACTIVATE_FRAMES); rightActive = rightCounter >= ACTIVATE_FRAMES; }

        anyRotateGesture = leftActive || rightActive;
        if (anyRotateGesture) {
          yangle = (yangle + ROT_SPEED_Y) % 360;
          xangle = (xangle + ROT_SPEED_X) % 360;
        }


        if (leftIdx !== null) {
          const lm = results.landmarks[leftIdx];
          const pinchDist = dist2D(lm[8], lm[4]);
          const isPinching = pinchDist < pinch_threshold;
          if (isPinching) pinchLeftCounter = Math.min(pinchLeftCounter + 1, PINCH_ACT_FRAMES);
          else pinchLeftCounter = Math.max(pinchLeftCounter - 1, -PINCH_DEACT_FRAMES);
          pinchLeftActive = pinchLeftCounter >= PINCH_ACT_FRAMES;
        } else { pinchLeftCounter = Math.max(pinchLeftCounter - 1, -PINCH_DEACT_FRAMES); pinchLeftActive = pinchLeftCounter >= PINCH_ACT_FRAMES; }



        if (rightIdx !== null) {
          const lm = results.landmarks[rightIdx];
          const pinchDist = dist2D(lm[8], lm[4]);
          const isPinching = pinchDist < pinch_threshold;
          if (isPinching) pinchRightCounter = Math.min(pinchRightCounter + 1, PINCH_ACT_FRAMES);
          else pinchRightCounter = Math.max(pinchRightCounter - 1, -PINCH_DEACT_FRAMES);
          pinchRightActive = pinchRightCounter >= PINCH_ACT_FRAMES;
        } else { pinchRightCounter = Math.max(pinchRightCounter - 1, -PINCH_DEACT_FRAMES); pinchRightActive = pinchRightCounter >= PINCH_ACT_FRAMES; }




        if (pinchLeftActive || pinchRightActive) {
          anyPinch = true;
          const controllerIdx = pinchRightActive ? rightIdx : leftIdx;
          const handLM = results.landmarks[controllerIdx];
          const normPalm = palmX(handLM);
          targetCubeX = mapHandXToSceneX(normPalm);
        }

        let rightLApplied = 0, leftLApplied = 0;
        if (rightIdx !== null) {
          const rightLM = results.landmarks[rightIdx];
          const d = detectLGesture(rightLM);
          if (d !== 0) rightLCounter = Math.min(rightLCounter + 1, L_ACTIVATE_FRAMES);
          else rightLCounter = Math.max(rightLCounter - 1, -L_DEACTIVATE_FRAMES);
          rightLActive = rightLCounter >= L_ACTIVATE_FRAMES ? d : 0;
          if (rightLActive !== 0 && thumbPointsLeft(rightLM)) rightLApplied = 1;
        } else { rightLCounter = Math.max(rightLCounter - 1, -L_DEACTIVATE_FRAMES); rightLActive = rightLCounter >= L_ACTIVATE_FRAMES ? rightLActive : 0; }


        if (leftIdx !== null) {
          const leftLM = results.landmarks[leftIdx];
          const d = detectLGesture(leftLM);
          if (d !== 0) leftLCounter = Math.min(leftLCounter + 1, L_ACTIVATE_FRAMES);
          else leftLCounter = Math.max(leftLCounter - 1, -L_DEACTIVATE_FRAMES);
          leftLActive = leftLCounter >= L_ACTIVATE_FRAMES ? d : 0;
          if (leftLActive !== 0 && thumbPointsRight(leftLM)) leftLApplied = -1;
        } else { leftLCounter = Math.max(leftLCounter - 1, -L_DEACTIVATE_FRAMES); leftLActive = leftLCounter >= L_ACTIVATE_FRAMES ? leftLActive : 0; }



        if (rightLApplied !== 0) scaleAction = rightLApplied;
        else if (leftLApplied !== 0) scaleAction = leftLApplied;
        else scaleAction = 0;

        if (scaleAction === 1) {
          modelUserScale = Math.min(user_scale_max, modelUserScale + scale_speed);
        } else if (scaleAction === -1) {

          modelUserScale = Math.max(user_scale_min, modelUserScale - scale_speed);
        }


        for (const lm of results.landmarks) {
          const drawingUtils = new DrawingUtils(canvasCtx);
          drawingUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { color: "#1C48E6", lineWidth: 5 });
          drawingUtils.drawLandmarks(lm, { color: "#B01CE6", lineWidth: 2 });

        }
      }




      canvasCtx.restore();

      if (webcamRunning) window.requestAnimationFrame(predictWebcam);
    }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm/vision_wasm_internal.js"
    crossorigin="anonymous"></script>
</body>

</html>